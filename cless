#! /usr/bin/ruby

$: << File.join(File.dirname($0), "lib")

require 'cless'
require 'optparse'

Version = [0, 0, 1]

if ENV["CLESS"]
  args = ENV["CLESS"].split + ARGV
else
  args = ARGV
end
options = {
  :column => false,
  :line => false,
  :grey => false,
  :hide => [],
}
onoff = proc { |k| "(" + (options[k] ? "on" : "off") + ")" }
opts = OptionParser.new do |opts|
  opts.banner = "Usage: example.rb [options] [file]\n" +
    "Column oriented less-like pager\n" +
    "Options: (default values in parentheses)"
  
  opts.on("--[no-]column", "Display column header #{onoff[:column]}") { |v|
    options[:column] = v
  }
  opts.on("--[no-]line", "Display line number #{onoff[:line]}") { |v|
    options[:line] = v
  }
  opts.on("--[no-]grey", "Grey every other line #{onoff[:grey]}") { |v|
    options[:grey] = v
  }
  opts.on("-h", "--hide COLUMNS", 
          "Comma separated list of columns to hide") { |v|
    a = v.split(',').collect { |x| x.to_i }.delete_if { |x| x <= 0 }
    options[:hide] += a
  }
  opts.on_tail("-v", "--version", "Show version and exit") {
    puts(Version.join('.'))
    exit(0)
  }
  opts.on_tail("-h", "--help", "This message") {
    puts(opts)
    exit(0)
  }
end
opts.parse!(args)

# Move around the file descriptor if not a tty!
if !$stdout.tty?
  $stderr.puts("Works only on terminals!")
  $stderr.puts(opts)
  exit(1)
end
if args.empty? && $stdin.tty?
  $stderr.puts("Cannot read from data tty")
  $stderr.puts(opts)
  exit(1)
end
if !$stdin.tty?
  # Better way to get a file descriptor to reopen
  # dup anyone?
  stdin, w = IO.pipe    
  w.close
  stdin.reopen($stdin)
  $stdin.reopen($stdout)
end

if args[0]
  ptr = MappedFile.new(args[0])
else
  ptr = MappedStream.new(stdin)
end
data = MapData.new(ptr)
display = LineDisplay.new(data, options)
manager = Manager.new(data, display)
trap("SIGTERM") { exit }
curses_init

display.col_hide(*options[:hide])

# $log = File.open("log", "w")
# $log.sync = true

begin
  manager.main_loop
ensure
  Ncurses.endwin
  ptr.munmap
end

