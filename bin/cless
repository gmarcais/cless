#! /usr/bin/ruby

require 'cless/cless'
require 'optparse'

Version = [0, 3, 16]

options = {
  :column => false,
  :col_start => 1,
  :line => false,
  :line_offset => false,
  :col_space => 1,
  :line_highlight => false,
  :line_highlight_period => 2,
  :line_highlight_shift => 0,
  :col_highlight => false,
  :col_highlight_period => 2,
  :col_highlight_shift => 0,
  :parse_header => true,
  :foreground => "none",
  :background => "none",
  :attribute => "bold",
  :names => nil,
  :type => nil,
  :formats => [],
  :ignore => [],
  :split_regexp => nil,
  :line_highlight_regexp => nil,
  :hide => [],
  :tmp_dir => Dir.tmpdir,
  :options_db => [],
  :separator => " ",
  :padding => " ",
  :start_line => 1,
  :header_line => nil,
}
onoff = proc { |k| "(" + (options[k] ? "on" : "off") + ")" }
val = proc { |k| "(" + (options[k] || "none").to_s + ")" }

opts = nil
loop do
  again = false
  opts = OptionParser.new do |opts|
    opts.banner = "Usage: cless [options] [file]\n" +
      "Column oriented less-like pager\n" +
      "Options: (default values in parentheses)"
    
    opts.on("--[no-]column", "Display column number #{onoff[:column]}") { |v|
      options[:column] = v
    }
    opts.on("--[no-]line", "Display line number #{onoff[:line]}") { |v|
      options[:line] = v
    }
    opts.on("--[no-]offset", "Display offset instead of line number " +
              onoff[:line_offset]) { |v|
      options[:line_offset] = v
    }
    opts.on("--[no-]line-highlight", "Hilight every other line " +
            onoff[:line_highlight]) { |v|
      options[:line_highlight] = v
    }
    opts.on("--line-period PERIOD", "Hilight period for lines " +
            val[:line_highlight_period]) { |v|
      options[:line_highlight_period] = v.to_i
    }
    opts.on("--line-highlight-regexp REGEXP", 
            "Hilight line on regular expression" + 
            val[:line_highlight_regexp]) { |v|
      options[:line_highlight_regexp] = Regexp.new(v)
    }
    opts.on("--line-shift SHIFT", "Hilight shift for lines " +
            val[:line_highlight_shift]) { |v|
      options[:line_highlight_shift] = v.to_i
    }
    opts.on("--[no-]column-highlight", "Hilight every other column " +
            onoff[:col_highlight]) { |v|
      options[:col_highlight] = v
    }
    opts.on("--column-period PERIOD", "Hilight period for columns " +
            val[:col_highlight_period]) { |v|
      options[:col_highlight_period] = v.to_i
    }
    opts.on("--column-shift SHIFT", "Hilight shift for columns " +
            val[:col_highlight_shift]) { |v|
      options[:col_highlight_shift] = v.to_i
    }
    opts.on("--[no-]column-names", "Display column names " +
              "#{onoff[:col_names]}") { |v|
      options[:col_names] = v
    }
    opts.on("--[no-]parse-header", "Parse header for options " +
              "#{onoff[:parse_header]}") { |v|
      options[:parse_header] = v
    }
    opts.on("--foreground COLOR", "Foreground color for hilight #{val[:foreground]}") { |v|
      options[:foreground] = v
    }
    opts.on("--background COLOR", "Background color for hilight #{val[:background]}") { |v|
      options[:background] = v
    }
    opts.on("--column-space NB", "Number of spaces between columns " +
            val[:col_space]) { |v|
      options[:col_space] = v.to_i
    }
    opts.on("--attribute ATTR", "Attribute for hilight #{val[:attribute]}") { |v|
      options[:attribute] = v
    }
    opts.on("--hide COLUMNS", 
            "Comma separated list of columns to hide") { |v|
      a = v.split(/[,\s]+/).collect { |x| x.to_i }
      a.delete_if { |x| x < 0 }
      options[:hide] += a
    }
    opts.on("--column-start INDEX", Integer,
            "first column index #{val[:col_start]}") { |v|
      options[:col_start] = v
    }
    opts.on("--start-line LINE", Integer,
            "first line to display #{val[:start_line]}") { |v|
      options[:start_line] = v
    }
    opts.on("--names NAMES", "Comma separated list of column names") { |v|
      options[:names] = v.split_with_quotes("\s,")
    }
    opts.on("--header-line LINE", Integer,
            "use given line as headers") { |v|
      options[:header_line] = v.to_i
    }
    opts.on("--options-db DB", "Path of a options db") { |v|
      options[:options_db] << v
    }
    opts.on("--format FORMAT", "Format for a column") { |v|
      options[:formats] << v
    }
    opts.on("--ignore PATTERN", "Line to ignore") { |v|
      options[:ignore] << v
    }
    opts.on("--split-regexp REGEXP", "Regular expression to split lines") { |v|
      v.gsub!(%r{^/|/$}, '')
      options[:split_regexp] = Regexp.new(v)
    }
    opts.on("--type TYPE", "Type of file") { |v|
      options[:type] = v
    }
    opts.on("-T", "--tmp-dir DIR", "Temporary directory #{val[:tmp_dir]}") { |v|
      options[:tmp_dir] = v
    }
    opts.on("--separator SEP", "Separator caracter between columns " +
            "(#{val[:separator]}") { |v|
      v = v[0, 1]
      options[:separator] = v unless v.empty? 
    }
    opts.on("--padding PAD", "Padding caracter (#{val[:padding]})") { |v|
      options[:padding] = v
    }
    opts.on_tail("-v", "--version", "Show version and exit") {
      puts(Version.join('.'))
      exit(0)
    }
    opts.on_tail("-h", "--help", "This message") {
      puts(opts)
      exit(0)
    }
  end

  if ENV["CLESS"]
    args = ENV["CLESS"].split_with_quotes
    ENV["CLESS"] = nil
    again = true
  else
    args = ARGV
  end
  begin
    opts.parse!(args)
  rescue => e
    $stderr.puts("Error (#{e.class}): #{e.message}")
    $stderr.puts(opts)
    exit(1)
  end
  break unless again
end

# Move around the file descriptor if not a tty!
if !$stdout.tty?
  $stderr.puts("Works only on terminals!")
  $stderr.puts(opts)
  exit(1)
end
if ARGV.empty? && $stdin.tty?
  $stderr.puts("Cannot read from data tty")
  $stderr.puts(opts)
  exit(1)
end
if !$stdin.tty?
  stdin = $stdin.dup
  $stdin.reopen($stdout)
end

class KeyboardInterrupt < StandardError; end

trap("SIGTERM") { exit }
trap("SIGINT") { raise KeyboardInterrupt, "Ctrl-C" }
trap("SIGQUIT") { exit }
trap("SIGHUP") { exit }

ptr = begin
        ARGV[0] ? MappedFile.new(ARGV[0]) : MappedStream.new(stdin, options)
      rescue ArgumentError => e
        $stderr.puts("Mmap failed: #{e.message}")
        exit(1)
      end

begin
  # Finish parsing options
  db = OptionsDB.new
  options[:options_db].each do |f| 
    begin
      db.parse_file(f)
    rescue => e
      $stderr.puts("Error with db #{f}: #{e.message}")
    end
  end
  type = options[:type] || ARGV[0]
  if type
    if (a = db.find(type))
      begin
        opts.parse(a)
      rescue => e
        $stderr.puts("Error with options from db: #{e.message}")
      end
    end
  end
  header_l = nil
  if options[:parse_header]
    header_l, a = ptr.parse_header(["type", "names", "format", "ignore"])
    opts.parse(a)
    opts = nil
  end
  
  data = MapData.new(ptr, options[:split_regexp])
  display = LineDisplay.new(data, options)
  manager = Manager.new(data, display, db)
  data.cache_fill(1)
  
  data.highlight_regexp = options[:line_highlight_regexp]
  display.col_headers = options[:names]
  display.col_hide(*options[:hide])
  options[:formats].each { |fmt| manager.column_format(fmt) }
  options[:ignore].each { |pat| manager.ignore_line(pat) }
  manager.ignore_line("1-#{header_l}") if header_l && header_l > 0
  if options[:header_line]
    begin
      manager.change_headers_to_line(options[:header_line])
    rescue => e
      $stderr.puts("--header-line #{options[:header_line]}: #{e.message}")
    end
  end
  data.goto_line(options[:start_line])

  # Start curses application
  Curses.new do |curses|
    display.initialize_curses
    manager.main_loop
  end
rescue KeyboardInterrupt
  # Quit normally
ensure
  ptr.munmap
end
