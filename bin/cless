#! /genome4/raid/gus/bin32/ruby

require 'cless/cless'
require 'optparse'

Version = [0, 3, 3]

options = {
  :column => false,
  :col_zero => false,
  :line => false,
  :line_offset => false,
  :col_space => 1,
  :grey => false,
  :parse_header => true,
  :foreground => "none",
  :background => "none",
  :attribute => "bold",
  :names => nil,
  :type => nil,
  :formats => [],
  :ignore => [],
  :split_regexp => nil,
  :hide => [],
  :tmp_dir => Dir.tmpdir,
  :options_db => [],
}
onoff = proc { |k| "(" + (options[k] ? "on" : "off") + ")" }
val = proc { |k| "(" + (options[k] || "none").to_s + ")" }

opts = nil
loop do
  again = false
  opts = OptionParser.new do |opts|
    opts.banner = "Usage: cless [options] [file]\n" +
      "Column oriented less-like pager\n" +
      "Options: (default values in parentheses)"
    
    opts.on("--[no-]column", "Display column number #{onoff[:column]}") { |v|
      options[:column] = v
    }
    opts.on("--[no-]column-zero", 
            "0-based numbering of column #{onoff[:col_zero]}") { |v|
      options[:col_zero] = v
    }
    opts.on("--[no-]line", "Display line number #{onoff[:line]}") { |v|
      options[:line] = v
    }
    opts.on("--[no-]offset", "Display offset instead of line number " +
              onoff[:line_offset]) { |v|
      options[:line_offset] = v
    }
    opts.on("--[no-]hilight", "Hilight every other line #{onoff[:grey]}") { |v|
      options[:grey] = v
    }
    opts.on("--[no-]column-names", "Display column names " +
              "#{onoff[:col_names]}") { |v|
      options[:col_names] = v
    }
    opts.on("--[no-]parse-header", "Parse header for options " +
              "#{onoff[:parse_header]}") { |v|
      options[:parse_header] = v
    }
    opts.on("--foreground COLOR", "Foreground color for hilight #{val[:foreground]}") { |v|
      options[:foreground] = v
    }
    opts.on("--background COLOR", "Background color for hilight #{val[:background]}") { |v|
      options[:background] = v
    }
    opts.on("--col-space NB", "Number of spaces between columns " +
            val[:col_space]) { |v|
      options[:col_space] = v.to_i
    }
    opts.on("--attribute ATTR", "Attribute for hilight #{val[:attribute]}") { |v|
      options[:attribute] = v
    }
    opts.on("--hide COLUMNS", 
            "Comma separated list of columns to hide") { |v|
      a = v.split(/[,\s]+/).collect { |x| x.to_i }
      a.delete_if { |x| x < 0 }
      options[:hide] += a
    }
    opts.on("--names NAMES", "Comma separated list of column names") { |v|
      options[:names] = v.split_with_quotes("\s,")
    }
    opts.on("--options-db DB", "Path of a options db") { |v|
      options[:options_db] << v
    }
    opts.on("--format FORMAT", "Format for a column") { |v|
      options[:formats] << v
    }
    opts.on("--ignore PATTERN", "Line to ignore") { |v|
      options[:ignore] << v
    }
    opts.on("--split-regexp REGEXP", "Regular expression to split lines") { |v|
      options[:split_regexp] = v
    }
    opts.on("--type TYPE", "Type of file") { |v|
      options[:type] = v
    }
    opts.on("-T", "--tmp-dir DIR", "Temporary directory #{val[:tmp_dir]}") { |v|
      options[:tmp_dir] = v
    }
    opts.on_tail("-v", "--version", "Show version and exit") {
      puts(Version.join('.'))
      exit(0)
    }
    opts.on_tail("-h", "--help", "This message") {
      puts(opts)
      exit(0)
    }
  end

  if ENV["CLESS"]
    args = ENV["CLESS"].split_with_quotes
    ENV["CLESS"] = nil
    again = true
  else
    args = ARGV
  end
  begin
    opts.parse!(args)
  rescue => e
    $stderr.puts("Error (#{e.class}): #{e.message}")
    $stderr.puts(opts)
    exit(1)
  end
  break unless again
end

# Move around the file descriptor if not a tty!
if !$stdout.tty?
  $stderr.puts("Works only on terminals!")
  $stderr.puts(opts)
  exit(1)
end
if ARGV.empty? && $stdin.tty?
  $stderr.puts("Cannot read from data tty")
  $stderr.puts(opts)
  exit(1)
end
if !$stdin.tty?
  stdin = $stdin.dup
  $stdin.reopen($stdout)
end

class KeyboardInterrupt < StandardError; end

trap("SIGTERM") { exit }
trap("SIGINT") { raise KeyboardInterrupt, "Ctrl-C" }
trap("SIGQUIT") { exit }

ptr = begin
        ARGV[0] ? MappedFile.new(ARGV[0]) : MappedStream.new(stdin, options)
      rescue ArgumentError => e
        $stderr.puts("Mmap failed: #{e.message}")
        exit(1)
      end

begin
  # Finish parsing options
  db = OptionsDB.new
  options[:options_db].each do |f| 
    begin
      db.parse_file(f)
    rescue => e
      $stderr.puts("Error with db #{f}: #{e.message}")
    end
  end
  type = options[:type] || ARGV[0]
  if type
    if (a = db.find(type))
      begin
        opts.parse(a)
      rescue => e
        $stderr.puts("Error with options from db: #{e.message}")
      end
    end
  end
  header_l = nil
  if options[:parse_header]
    header_l, a = ptr.parse_header(["type", "names", "format", "ignore"])
    opts.parse(a)
    opts = nil
  end
  begin
    s = options[:split_regexp]
    s && s.gsub!(%r{^/|/$}, '')
    split_regexp = (!s || s.empty?) ? nil : Regexp.new(s)
  rescue => e
    $stderr.puts("Invalid regexp /#{s}/: #{e.message}")
    $stderr.puts("Using default whitespaces")
    split_regexp = nil
  end
  
  # Start curses application
  Curses.new do |curses|
    data = MapData.new(ptr, split_regexp)
    display = LineDisplay.new(data, options)
    manager = Manager.new(data, display, curses, db)

    display.col_headers = options[:names]
    display.col_hide(*options[:hide])
    options[:formats].each { |fmt| manager.column_format(fmt) }
    options[:ignore].each { |pat| manager.ignore_line(pat) }
    manager.ignore_line("1-#{header_l}") if header_l && header_l > 0

    manager.main_loop
  end
rescue KeyboardInterrupt
  # Quit normally
ensure
  ptr.munmap
end
