#! /usr/bin/env ruby

require 'cless/cless'
require 'optparse'

Version = [0, 1, 5]

options = {
  :column => false,
  :col_zero => false,
  :line => false,
  :grey => false,
  :foreground => "none",
  :background => "none",
  :attribute => "bold",
  :hide => [],
  :tmp_dir => Dir.tmpdir,
  :name_db => [],
}
onoff = proc { |k| "(" + (options[k] ? "on" : "off") + ")" }
val = proc { |k| "(" + (options[k] || "none").to_s + ")" }

opts = nil
loop do
  again = false
  opts = OptionParser.new do |opts|
    opts.banner = "Usage: cless [options] [file]\n" +
      "Column oriented less-like pager\n" +
      "Options: (default values in parentheses)"
    
    opts.on("--[no-]column", "Display column number #{onoff[:column]}") { |v|
      options[:column] = v
    }
    opts.on("--[no-]column-zero", 
            "0-based numbering of column #{onoff[:col_zero]}") { |v|
      options[:col_zero] = v
    }
    opts.on("--[no-]line", "Display line number #{onoff[:line]}") { |v|
      options[:line] = v
    }
    opts.on("--[no-]hilight", "Hilight every other line #{onoff[:grey]}") { |v|
      options[:grey] = v
    }
    opts.on("--[no-]column-names", "Display column names") { |v|
      options[:col_names] = v
    }
    opts.on("--foreground COLOR", "Foreground color for hilight #{val[:foreground]}") { |v|
      options[:foreground] = v
    }
    opts.on("--background COLOR", "Background color for hilight #{val[:background]}") { |v|
      options[:background] = v
    }
    opts.on("--attribute ATTR", "Attribute for hilight #{val[:attribute]}") { |v|
      options[:attribute] = v
    }
    opts.on("--name-db DB", "Path of a column name db") { |v|
      options[:name_db] << v
    }
    opts.on("-T", "--tmp-dir DIR", "Temporary directory #{val[:tmp_dir]}") { |v|
      options[:tmp_dir] = v
    }
    opts.on("-h", "--hide COLUMNS", 
            "Comma separated list of columns to hide") { |v|
      a = v.split(',').collect { |x| x.to_i }.delete_if { |x| x <= 0 }
      options[:hide] += a
    }
    opts.on_tail("-v", "--version", "Show version and exit") {
      puts(Version.join('.'))
      exit(0)
    }
    opts.on_tail("--help", "This message") {
      puts(opts)
      exit(0)
    }
  end

  if ENV["CLESS"]
    args = ENV["CLESS"].split
    ENV["CLESS"] = nil
    again = true
  else
    args = ARGV
  end
  begin
    opts.parse!(args)
  rescue => e
    $stderr.puts("Error (#{e.class}): #{e.message}")
    $stderr.puts(opts)
    exit(1)
  end
  break unless again
end

# Move around the file descriptor if not a tty!
if !$stdout.tty?
  $stderr.puts("Works only on terminals!")
  $stderr.puts(opts)
  exit(1)
end
if ARGV.empty? && $stdin.tty?
  $stderr.puts("Cannot read from data tty")
  $stderr.puts(opts)
  exit(1)
end
if !$stdin.tty?
  stdin = $stdin.dup
  $stdin.reopen($stdout)
end

ptr = begin
        ARGV[0] ? MappedFile.new(ARGV[0]) : MappedStream.new(stdin, options)
      rescue ArgumentError => e
        $stderr.puts("Mmap failed: #{e.message}")
        exit(1)
      end
opts = nil
trap("SIGTERM") { exit }
trap("SIGINT") { exit }
trap("SIGQUIT") { exit }

begin
  Curses.new { |curses|
    
    db = NameDB.new(*options[:name_db])
    data = MapData.new(ptr)
    display = LineDisplay.new(data, options)
    manager = Manager.new(data, display, curses, db)
    
    if f = ARGV[0]
      display.col_headers = db.find(f)
    end
    display.col_hide(*options[:hide])

    manager.main_loop
  }
ensure
  ptr.munmap
end
